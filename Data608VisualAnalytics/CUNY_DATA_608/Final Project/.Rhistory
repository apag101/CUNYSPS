library(gridExtra)
library(shiny)
glmod<-glm(sprtcode~grad2011+collenroll2011+grad2012+collenroll2012,data=mdata,family="binomial"(link="logit"))
tidy(glmod)
glance(glmod)
par(mfrow = c(2,2))
plot(glmod)
glmod<-glm(sprtcode~grad2011+collenroll2011+grad2012+collenroll2012,data=mdata,family="binomial"(link="logit"))
tidy(glmod)
glance(glmod)
par(mfrow = c(2,2))
plot(glmod)
tidy(glmod)
runApp()
runApp()
tidy(glmod)
glance(glmod)
tidy(glmod)
glance(glmod)
augment(glmod)
runApp()
glance(glmod)
tidy(glmod)
tidy(glmod)
glance(glmod)
runApp()
runApp()
glance(glmod)
glance(glmod)
augment(glmod)
glance(glmod)
tidy(glmod)
runApp()
knitr::opts_chunk$set(
echo = TRUE,
message = FALSE,
warning = FALSE
)
#install.packages('rsconnect')
rsconnect::setAccountInfo(name='apag101', token='98AFD680E6AB821CF1F430EF2A6DABFC', secret='rgMjLtYC8JcXgTFRb5TWOSzKlLXk4W4Nkp4fr1eU')
library(rsconnect)
rsconnect::deployApp('..\\Final Project')
runApp()
list.of.packages <- c("alluvial","caret","caret","corrplot","corrplot","data.table","dplyr","faraway","forcats","geosphere","ggplot2","ggplot2","ggplot2","grid","gridExtra","jtools","kableExtra","knitr","leaflet","leaflet.extras","leaps","lubridate","maps","MASS","mice","naniar","pander","patchwork","prettydoc","pROC","psych","RColorBrewer","readr","reshape2","scales","stringr","tibble","tidyr","tidyverse","xgboost","widgetframe")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
require(knitr)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE,fig.align='center')
library(faraway)
library(MASS)
library(psych)
library(pROC)
library(corrplot)
library(jtools)
library(mice)
library('corrr')
library(kableExtra)
library(gridExtra)
library(pander)
#devtools::install_github("thomasp85/patchwork")
library(patchwork)
library(tidyverse)
library(ggplot2)
library(ggplot2)
library(reshape2)
library(leaps)
library(caret)
library(naniar)
library('ggplot2') # visualisation
library('scales') # visualisation
library('grid') # visualisation
library('RColorBrewer') # visualisation
library('corrplot') # visualisation
library('alluvial') # visualisation
library('dplyr') # data manipulation
library('readr') # input/output
library('data.table') # data manipulation
library('tibble') # data wrangling
library('tidyr') # data wrangling
library('stringr') # string manipulation
library('forcats') # factor manipulation
library('lubridate') # date and time
library('geosphere') # geospatial locations
library('leaflet') # maps
library('leaflet.extras') # maps
library('maps') # maps
library('xgboost') # modelling
library('caret') # modelling
library('widgetframe') #visualizaiton
# Define multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
# Define multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
var_stats<- function(df){
wt<-data.frame(columns=colnames(df))
wt$na_count <- sapply(df, function(y) sum(is.na(y)))
wt$neg_count <- sapply(df, function(y) sum(y<0))
wt$zero_count <- sapply(df, function(y) sum(as.integer(y)==0))
wt$unique_count <- sapply(df, function(y) sum(n_distinct(y)))
print(wt)
return(wt)
}
# Define multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
var_stats<- function(df){
wt<-data.frame(columns=colnames(df))
wt$na_count <- sapply(df, function(y) sum(is.na(y)))
wt$neg_count <- sapply(df, function(y) sum(y<0))
wt$zero_count <- sapply(df, function(y) sum(as.integer(y)==0))
wt$unique_count <- sapply(df, function(y) sum(n_distinct(y)))
print(wt)
return(wt)
}
# Define multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
train <- as_tibble(fread('data/train.csv'))
test <- as_tibble(fread('data/test.csv'))
sample_submit <- as_tibble(fread('data/sample_submission.csv'))
# Define multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
var_stats<- function(df){
wt<-data.frame(columns=colnames(df))
wt$na_count <- sapply(df, function(y) sum(is.na(y)))
wt$neg_count <- sapply(df, function(y) sum(y<0))
wt$zero_count <- sapply(df, function(y) sum(as.integer(y)==0))
wt$unique_count <- sapply(df, function(y) sum(n_distinct(y)))
print(wt)
return(wt)
}
str(train)
#glimpse(train)
#summary(train)
#describe(train)
train <- as_tibble(fread('data/train.csv'))
test <- as_tibble(fread('data/test.csv'))
sample_submit <- as_tibble(fread('data/sample_submission.csv'))
combine <- combine %>% mutate(dset = factor(dset))
names(train)
names(test)
#glimpse(test)
#
vars_to_add <- train[!names(train) %in% names(test)]
#vvvvv
## Combining train and test
combine <- rbind(train %>% mutate(dset = "train"),
test %>% mutate(dset = "test",
dropoff_datetime = NA,
trip_duration = NA))
combine <- combine %>% mutate(dset = factor(dset))
train <- train %>%
mutate(pickup_datetime = ymd_hms(pickup_datetime),
dropoff_datetime = ymd_hms(dropoff_datetime),
vendor_id = factor(vendor_id),
passenger_count = factor(passenger_count))
glimpse(combine)
var_stats(combine)
#ggplot(combine, aes(trip_duration)) +
#  geom__histogram(aes(y = ..density..)
attach(train)
#plot(trip_duration ~ dropoff_longitude,pch  = 20,cex  = 2,col  = "grey")
sample_model = lm(trip_duration ~ dropoff_longitude)
plot(trip_duration ~ dropoff_longitude,
pch  = 20,
cex  = 2,
col  = "grey")
abline(sample_model, lwd = 3, col = "darkorange")
summary(sample_model)
confint(sample_model, level = 0.99)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration), by = 50)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
plot(trip_duration ~ dropoff_longitude, data = train,
xlab = "Trip Duration",
ylab = "Dropoff Logitude",
main = "vs",
pch  = 20,
cex  = 2,
col  = "grey",
ylim = c(min(dist_pi_band), max(dist_pi_band)))
abline(sample_model, lwd = 5, col = "darkorange")
lines(trip_duration_grid, dist_ci_band[,"lwr"], col = "dodgerblue", lwd = 3, lty = 2)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration), by = 50)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
plot(trip_duration ~ dropoff_longitude, data = train,
xlab = "Trip Duration",
ylab = "Dropoff Logitude",
main = "vs",
pch  = 20,
cex  = 2,
col  = "grey",
ylim = c(min(dist_pi_band), max(dist_pi_band)))
abline(sample_model, lwd = 5, col = "darkorange")
lines(trip_duration_grid, dist_ci_band[,"lwr"], col = "dodgerblue", lwd = 3, lty = 2)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration), by = 50)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
plot(trip_duration ~ dropoff_longitude, data = train,
xlab = "Trip Duration",
ylab = "Dropoff Logitude",
main = "vs",
pch  = 20,
cex  = 2,
col  = "grey",
ylim = c(min(dist_pi_band), max(dist_pi_band)))
abline(sample_model, lwd = 5, col = "darkorange")
str(newdata)
newdata
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
newdata
nrows(newdata)
nrow(newdaa)
nrow(newdata)
nrow('newdata')
nrow(newdata)
newdata
data.frame(speed = trip_duration_grid)
newdata = data.frame(speed = trip_duration_grid)
nrow(newdata)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
nrow(newdata)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
nrow(sample_model)
nrow(train$trip_duration)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration), by = 50)
trip_duration
trip_duration_grid
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
nrow(trip_duration_grid)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration), by = 50)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
nrow(sample_model)
nrow(trip_duration)
nrow(ttrip_duration_grid)
nrow(trip_duration_grid)
nrow(train$trip_duration)
nrow(train)
nrow(train)/50
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
train$trip_duration
ncol(train$trip_duration)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration), by = 50)
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
plot(trip_duration ~ dropoff_longitude, data = train,
xlab = "Trip Duration",
ylab = "Dropoff Logitude",
main = "vs",
pch  = 20,
cex  = 2,
col  = "grey",
ylim = c(min(dist_pi_band), max(dist_pi_band)))
abline(sample_model, lwd = 5, col = "darkorange")
lines(trip_duration_grid, dist_ci_band[,"lwr"], col = "dodgerblue", lwd = 3, lty = 2)
summary(sample_model)
confint(sample_model, level = 0.99)
nrow(train$dropoff_longitude)
train$dropoff_longitude
train$dropoff_latitude
train$pickup_datetime
train$trip_duration
dist_pi_band
max(dist_pi_band)
dist_pi_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "prediction", level = 0.99)
trip_duration_grid = seq(min(train$trip_duration), max(train$trip_duration))
dist_ci_band = predict(sample_model,
newdata = data.frame(speed = trip_duration_grid),
interval = "confidence", level = 0.99)
3526282/50
dist_ci_band
mlm_model = lm(trip_duration ~ ., data = train)
xx
#xx
fit_quad = lm(y ~ poly(trip_duration, degree = 2), data = poly_data)
??poly_data
which(hatvalues(sample_model) > 2 * mean(hatvalues(sample_model)), TRUE)
rstandard(sample_model)[abs(rstandard(sample_model)) > 2]
cooks.distance(sample_model)[11] > 4 / length(cooks.distance(sample_model))
cd_sample_model_add = cooks.distance(sample_model)
sum(cd_sample_model_add > 4 / length(cd_sample_model_add))
large_cd_train = cd_sample_model_add > 4 / length(cd_sample_model_add)
cd_sample_model_add[large_cd_train]
coef(sample_model)
sample_model_add_fix = lm(trip_duration ~ dropoff_longitude,
data = train,
subset = cd_sample_model_add <= 4 / length(cd_sample_model_add))
coef(sample_model_add_fix)
plot(sample_model)
mlm_model = lm(trip_duration ~ ., data = train)
