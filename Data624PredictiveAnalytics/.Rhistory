names(segmentationOriginal)
segData<-subset(segmentationOriginal, Case == "Train")
cell <-segData$Cell
class<-segData$Class
case<-segData$Case
segData<-segData[,-(1:3)]
statusColNum<-grep("Status", names(segData))
statusColNum
segData<- segData[, -statusColNum]
library(e1071)
skewValues<-apply(segData, 2, skewness)
head(skewValues)
library(caret)
Ch1AreaTrans<- BoxCoxTrans(segData$ConvexHullPerimRatioCh1)
Ch1AreaTrans
head(segData$ConvexHullPerimRatioCh1)
predict(Ch1AreaTrans, head(segData$ConvexHullPerimRatioCh1))
pcaObject<-prcomp(segData, center=TRUE, scale. = TRUE)#Principle Component Analysis transformation
percentVariance<- pcaObject$sd^2/sum(pcaObject$sd^2)*100
percentVariance[1:3]
head(pcaObject$x[, 1:5])
head(pcaObject$rotation[, 1:3])
spatialSign(segData)
trans<-preProcess(segData, method=c("BoxCox","center","scale","pca"))#applies all transformations listed
trans
transformed<-predict(trans,segData)
head(transformed[,1:5])
nearZeroVar(segData)
correlations<-cor(segData)
dim(correlations)
correlations[1:4,1:4]
library(corrplot)
corrplot(correlations, order = "hclust")
highcorr<-findCorrelation(correlations, cutoff = .75)#find corr up to cutoff
length(highcorr)
head(highcorr)
filteredSegData<-segData[, -highcorr]
filteredSegData
library(caret)
data(cars)
type <- c("convertible", "coupe", "hatchback", "sedan", "wagon")
cars$Type <- factor(apply(cars[, 14:18], 1, function(x) type[which(x == 1)]))
carSubset <- cars[sample(1:nrow(cars), 20), c(1, 2, 19)]
head(carSubset)
names(cars)
levels(cars$Type)
simpleMod<-dummyVars(~Mileage+Type, data=carSubset,levelsOnly = TRUE)
simpleMod
predict(simpleMod, head(carSubset))
withInteraction<-dummyVars(~Mileage+Type+Mileage:Type, data=carSubset,levelsOnly = TRUE)
withInteraction
predict(withInteraction, head(carSubset))
library(AppliedPredictiveModeling)
data(solibility)
data(solubility)
ls(pattern = "solT")
ls
ls()
set.seed(2)
sample(names(solTrainX),8)
trainingData<- solTrainXtrans
trainingData$Solubility<-solTrainY
trainingData
View(trainingData)
trainingData$Solubility
lmFitAllPredictors<-lm(SSolubility~., data=trainingData)
lmFitAllPredictors<-lm(Solubility~., data=trainingData)
summary(lmFitAllPredictors)
lmPred1<-predict(lmFitAllPredictors, solTestXtrans)
head(llmPred1)
head(lmPred1)
lmValues1<-data.frame(obs = solTestY, pred=lmPred1)
defaultSummary(lmValues1)
knitr::opts_chunk$set(echo = TRUE)
rlmFitAllPredictors<-rml(Solubility~.,data=trainingData)
rlmFitAllPredictors<-rlm(Solubility~.,data=trainingData)
library(MASS)
rlmFitAllPredictors<-rlm(Solubility~.,data=trainingData)
ctrl<-trainControl(method="cv", number=10)
??trainControl
library(caret)
ctrl<-trainControl(method="cv", number=10)
set.seed(100)
lmFit1<-train(x = solTrainXtrans, y=solTrainY, method="lm", trControl =ctrl)
lmFit1
lmFit1<-train(x = solTrainXtrans, y=solTrainY, method="lm", trControl =ctrl)
lmFit1<-train(x = solTrainXtrans, y=solTrainY, method="lm", trControl =ctrl)
xyplot(solTrainY ~ predict(lmFit1))
xyplot(solTrainY ~ predict(lmFit1),
type = c("p", "g"),
xlab = "Predicted", ylab="Observed")
xyplot(resid(lmFit1) ~ predict(lmFit1),
type = c("p", "g"),
xlab = "Predicted", ylab="Residuals")
corThesh <- .9
tooHigh<- findCorrelation(cor(solTrainXtrans), corThresh)
tooHigh<- findCorrelation(cor(solTrainXtrans), corThresh)
corThresh <- .9
tooHigh<- findCorrelation(cor(solTrainXtrans), corThresh)
corrPred<-names(solTrainXtrans)[tooHigh]
corrPred
tooHigh
trainXfiltered<-solTrainXtrans[, -tooHigh]
trainXfiltered
testXfiltered<- solTestXtrans[, -tooHigh]
testXfiltered
set.seed(100)
lmFiltered<-train(solTrainXtrans, solTrainY, method="lm", trControl=ctrl)
lmFiltered
set.seed(100)
rlmPCA<-train(solTrainXtrans, solTrainY,
method = "rlm",
preProcess = "pca",
trControl = ctrl)
rlmPCA<-train(solTrainXtrans, solTrainY,
method = "rlm",
preProcess = "pca",
trControl = ctrl)
```
rlmPCA
#Parial Least Square
plstFit<- plsr
#Parial Least Square
library(pls)
plstFit<- plsr
plstFit<- plsr(Solubility~., data=trainingData)
predict(plsFit, solTestXtrans,[1:5,], ncomp=1:2)
predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
plsFit<- plsr(Solubility~., data=trainingData)
plsFit<- plsr(Solubility~., data=trainingData)
predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
set.seed(100)
plsTune<-train(solTrainXtrans, solTrainY,
method="pls",
tuneLength = 20,
trControl=ctrl,
preProc=c("center", "scale"))
plstune
plsTune
plsTune
rlmPCA
library(elasticnet)
install.packages("elasticnet")
library(elasticnet)
library(elasticnet)
ridgeModel<- enet(x=as.matrix(solTrainXtrans), y= solTrainY,
lambda = .001)
ridgeModel
ridgePred<- predict(ridgeModel, newx = as.matrix(solTestXtrans),
s=1, mode="fraction",
type="fit")
ridgePred
head(ridgePred)
head(ridgePred)
head(ridgePred$fit)
ridgeGrid<-data.frame(.lambda = seq(0, .1, length=15))
set.seed(100)
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
knitr::opts_chunk$set(echo = TRUE)
library(elasticnet)
ridgeModel<- enet(x=as.matrix(solTrainXtrans), y= solTrainY,
lambda = .001)
ridgePred<- predict(ridgeModel, newx = as.matrix(solTestXtrans),
s=1, mode="fraction",
type="fit")
head(ridgePred$fit)
ridgeGrid<-data.frame(.lambda = seq(0, .1, length=15))
set.seed(100)
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
set.seed(100)
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
#Parial Least Square
library(pls)
library(MASS)
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
library(AppliedPredictiveModeling)
library(MASS)
library(caret)
#Parial Least Square
library(pls)
#Ridge Model
library(elasticnet)
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
knitr::opts_chunk$set(echo = TRUE)
library(AppliedPredictiveModeling)
data(solubility)
ls(pattern = "solT")
set.seed(2)
sample(names(solTrainX),8)
trainingData<- solTrainXtrans
trainingData$Solubility<-solTrainY
lmFitAllPredictors<-lm(Solubility~., data=trainingData)
summary(lmFitAllPredictors)
lmPred1<-predict(lmFitAllPredictors, solTestXtrans)
head(lmPred1)
library(MASS)
lmValues1<-data.frame(obs = solTestY, pred=lmPred1)
defaultSummary(lmValues1) #estimate test performance
library(MASS)
lmValues1<-data.frame(obs = solTestY, pred=lmPred1)
defaultSummary(lmValues1) #estimate test performance
?? defaultSummary
library(AppliedPredictiveModeling)
data(solubility)
ls(pattern = "solT")
set.seed(2)
sample(names(solTrainX),8)
trainingData<- solTrainXtrans
trainingData$Solubility<-solTrainY
lmFitAllPredictors<-lm(Solubility~., data=trainingData)
summary(lmFitAllPredictors)
lmPred1<-predict(lmFitAllPredictors, solTestXtrans)
head(lmPred1)
library(MASS)
library(caret)
lmValues1<-data.frame(obs = solTestY, pred=lmPred1)
defaultSummary(lmValues1) #estimate test performance
rlmFitAllPredictors<-rlm(Solubility~.,data=trainingData) #robust linear regression from MASS package which employs the Huber approach
library(caret)
ctrl<-trainControl(method="cv", number=10) #10 fold cross-validation using trainControl from caret library
set.seed(100)
lmFit1<-train(x = solTrainXtrans, y=solTrainY, method="lm", trControl =ctrl)
lmFit1
xyplot(solTrainY ~ predict(lmFit1),
type = c("p", "g"),
xlab = "Predicted", ylab="Observed")
xyplot(resid(lmFit1) ~ predict(lmFit1),
type = c("p", "g"),
xlab = "Predicted", ylab="Residuals")
corThresh <- .9
tooHigh<- findCorrelation(cor(solTrainXtrans), corThresh)
corrPred<-names(solTrainXtrans)[tooHigh]
trainXfiltered<-solTrainXtrans[, -tooHigh]
testXfiltered<- solTestXtrans[, -tooHigh]
set.seed(100)
lmFiltered<-train(solTrainXtrans, solTrainY, method="lm", trControl=ctrl)
lmFiltered
set.seed(100)
rlmPCA<-train(solTrainXtrans, solTrainY,
method = "rlm",
preProcess = "pca",
trControl = ctrl)
rlmPCA
#Parial Least Square
library(pls)
plsFit<- plsr(Solubility~., data=trainingData)
predict(plsFit, solTestXtrans[1:5,], ncomp=1:2)
set.seed(100)
plsTune<-train(solTrainXtrans, solTrainY,
method="pls",
tuneLength = 20,
trControl=ctrl,
preProc=c("center", "scale"))
plsTune
#Ridge Model
library(elasticnet)
ridgeModel<- enet(x=as.matrix(solTrainXtrans), y= solTrainY,
lambda = .001)
ridgePred<- predict(ridgeModel, newx = as.matrix(solTestXtrans),
s=1, mode="fraction",
type="fit")
head(ridgePred$fit)
ridgeGrid<-data.frame(.lambda = seq(0, .1, length=15))
set.seed(100)
ridgeRegFit<- train(solTrainXtrans, solTrainY,
method="ridge",
tuneGrid=ridgeGrid,
trControl=ctrl,
preProc = c("center", "scale"))
ridgeRegFit
enetModel<- enet(x = as.matrix(solTrainXtrans), y=solTrainY,
lambda = .01, normalize = TRUE)
enetPred<- predict(enetModel, newx = as.matrix(solTestXtrans),
s =.1, mode = "fraction",
type = "fit")
names(enetPred)
head(enetPred$fit)
enetCoef<-predict(enetModel, newx = as.matrix(solTestXtrans),
s=.1, mode ="fraction",
type = "coefficients")
tail(enetCoef$coefficients)
enetGrid<-expand.grid(.lamda = c(0,0.01,.1),
.fraction = seq(.05,1, length=20))
set.seed(100)
enetTune<-train(solTrainXtrans, solTrainY,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale"))
ridgeRegFit
enetModel<- enet(x = as.matrix(solTrainXtrans), y=solTrainY,
lambda = .01, normalize = TRUE)
enetPred<- predict(enetModel, newx = as.matrix(solTestXtrans),
s =.1, mode = "fraction",
type = "fit")
names(enetPred)
head(enetPred$fit)
enetCoef<-predict(enetModel, newx = as.matrix(solTestXtrans),
s=.1, mode ="fraction",
type = "coefficients")
tail(enetCoef$coefficients)
enetGrid<-expand.grid(.lamda = c(0,0.01,.1),
.fraction = seq(.05,1, length=20))
set.seed(100)
enetTune<-train(solTrainXtrans, solTrainY,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale"))
enetGrid<-expand.grid(.lambda = c(0,0.01,.1),
.fraction = seq(.05,1, length=20))
set.seed(100)
enetTune<-train(solTrainXtrans, solTrainY,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale"))
enetTune<-train(solTrainXtrans, solTrainY,
method = "enet",
tuneGrid = enetGrid,
trControl = ctrl,
preProc = c("center", "scale"))
```
plot(enetTune)
knitr::opts_chunk$set(
echo = FALSE,
message = FALSE,
warning = FALSE
)
#knitr::opts_chunk$set(echo = TRUE)
require(knitr)
library(ggplot2)
library(tidyr)
library(MASS)
library(psych)
library(kableExtra)
library(dplyr)
library(faraway)
library(gridExtra)
library(reshape2)
library(leaps)
library(pROC)
library(caret)
library(naniar)
library(pander)
library(pROC)
library(mlbench)
library(e1071)
library(fpp2)
library(mlr)
library(AppliedPredictiveModeling)
data(permeability)
glimpse(permeability)
describe(permeability)
glimpse(permeability)
describe(permeability)
View(permeability)
str(permeability)
per<-nearZeroVar(permeability)
per
?nearZeroVar
per<-nearZeroVar(permeability, saveMetrics = FALSE)
per
per<-nearZeroVar(permeability, saveMetrics = TRUE)
per
nearZeroVar(permeability)
per<-nearZeroVar(permeability, saveMetrics = TRUE)
nearZeroVar(permeability, saveMetrics = TRUE)
nearZeroVar(permeability, saveMetrics = FALSE)
nonzper<-permeability[-nzper]
nzper<-nearZeroVar(permeability, saveMetrics = TRUE)
nonzper<-permeability[-nzper]
nonzper<-permeability[,-nzper]
nonzper<-permeability[-nzper,]
nonzper<-names(permeability)[-nzper,]
nonzper
nonzper<-names(permeability)[-nzper]
nonzper
nzper<-nearZeroVar(permeability, saveMetrics = TRUE)
nonzper<-names(permeability)[-nzper]
nonzper
names(permeability)
permeability
names(permeability)
str(permeability)
names(permeability)
nzper
permeability[-nzper]
nzper
nzper<-nearZeroVar(permeability)
nonzper<-names(permeability)[-nzper]
nonzper
nearZeroVar(permeability)
permeability[-nzper]
data.frame(permeability)
nearZeroVar(data.frame(permeability)
)
permeability
data.frame(permeability)
data.frame(permeability)
nzper<-nearZeroVar(permeability, uniqueCut = 10)
nzper
permeability
describe(permeability)
str(permeability[, -integer(0)])
str(permeability[, -integer(0.2)])
str(permeability[, >integer(0.2)])
hist(permeability)
boxplot(permeability)
plot(permeability)
nzper<-nearZeroVar(permeability, uniqueCut = 1)
nonzper<-names(permeability)[-nzper]
nonzper
nearZeroVar(permeability, uniqueCut = 1)
nearZeroVar(permeability, uniqueCut = .1)
nearZeroVar(permeability, uniqueCut = .06)
nzper<-nearZeroVar(permeability)
table(permeability)
nzpermeability <- permeability[, -nearZeroVar(permeability)]
nzpermeability
nrow(nzpermeability)
cor(permeability)
glimpse(permeability, fingerprints)
glimpse( fingerprints)
describe(fingerprints)
dim(fingerprints)
nzfinger<-nearZeroVar(permeability)
fingerprints <- fingerprints[,-nzfinger]
dim(fingerprints)
nzfinger<-nearZeroVar(fingerprints)
dim(fingerprints)
data(fingerprints)
dim(fingerprints)
data(fingerprints)
data(fingerprints)
glimpse( fingerprints)
describe(fingerprints)
library(AppliedPredictiveModeling)
data(fingerprints)
glimpse( fingerprints)
describe(fingerprints)
str(permeability[, >integer(0.2)])l
rm(fingerprints)
ls
library(AppliedPredictiveModeling)
data(fingerprints)
glimpse( fingerprints)
describe(fingerprints)
knitr::opts_chunk$set(
echo = FALSE,
message = FALSE,
warning = FALSE
)
#knitr::opts_chunk$set(echo = TRUE)
require(knitr)
library(ggplot2)
library(tidyr)
library(MASS)
library(psych)
library(kableExtra)
library(dplyr)
library(faraway)
library(gridExtra)
library(reshape2)
library(leaps)
library(pROC)
library(caret)
library(naniar)
library(pander)
library(pROC)
library(mlbench)
library(e1071)
library(fpp2)
library(mlr)
library(AppliedPredictiveModeling)
data(fingerprints)
glimpse( fingerprints)
glimpse( fingerprints)
describe(fingerprints)
View(fingerprints)
View(fingerprint)
